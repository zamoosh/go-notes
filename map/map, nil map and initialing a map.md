## تا حالا شده که یک map رو بسازید و فکر کنید که آیا ممکن است که مقدار آن nil باشد یا خیر؟ تو این یادداشت قراره که توضیح دهیم

### روش اول:

code: 
```go
m := map[string]any{}

println(len(m))
println(m == nil)
println(m)
```

outputs: 
```
0
false
0xc000054700
```
پس در این روش، `map`، برابر با nil`nil` نشد.
**توضیح**: در این روش، مقدار `map`، به صورت فیزیکی در مموری رزرو شده است و درون متغیر `m` ریخته شده است؛ به عبارتی، متغیر `m`، یک متغیر` by value` است.

### نکات مهم: 👇
- دقت کنید که `0xc000054700` یعنی خانه‌ای از مموری، برای این map اختصاص داده شده است.

---


### روش دوم:

code: 
```go
m := new(map[string]any)

println(len(*m))
println(*m == nil)
println(*m)
```

output: 
```
0
true
0x0
```
در این روش، مقدار `m`، برابر با `nil` شد؛ دلیل‌اش هم این است که متغیر m، یک متغیرِ `by pointer` است، یعنی صرفا یک اشاره‌گر است که به جایی از حافظه که قرار است یک `map` با کلیدهای `string` و مقادیر از جنس `any` حمل کند، اشاره می‌کند. 

دقت کنید که مقدار `m*` نیز برابر با هیچ `(0x0)` است؛ یعنی این خانه از مموری، هنوز مقداری ندارد.


### نکات مهم: 👇
-  دقت کنید که در زبان `GO`، طول یک `map` که برابر با `nil` است، تغریف شده که برابر با `0` باشد. 
- دوم اینکه کلیدواژه‌ی `new`، صرفا یک اشاره‌گر با جنس داده شده می‌سازد و به آن مقدار نمی‌دهد، پس طبیعی هست که مقدار یک اشاره‌گرِ ساخته شده توسط `new`، برابر با `0x0` باشد.



---



### روش سوم: 
code: 
```go
m := make(map[string]any)  
println(len(m))  
println(m == nil)  
println(m)
```

output: 
```
0
false
0xc000106f08
```
مانند روش اول، ساخت یک `map`، با استفاده از `make`، آن را به **صورت فیزیکی** مقدار دهی اولیه می‌کند و صحبت دیگری نمی‌ماند...